// Copyright (C)2022 - Eduard Heidt
//
// Author: Eduard Heidt (eh2k@gmx.de)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// See http://creativecommons.org/licenses/MIT/ for more information.
//

#include "../squares-and-circles-api.h"

#undef SAMPLE_RATE
#define protected public

#include "open303/src/rosic_AnalogEnvelope.cpp"
#include "open303/src/rosic_EllipticQuarterBandFilter.cpp"
#include "open303/src/rosic_DecayEnvelope.cpp"
#include "open303/src/rosic_LeakyIntegrator.cpp"
#include "open303/src/wavetable_gen/rosic_MipMappedWaveTable.cpp"
#include "open303/src/wavetable_gen/rosic_FourierTransformerRadix2.cpp"
#include "open303/src/wavetable_gen/rosic_Complex.cpp"
#include "open303/src/rosic_RealFunctions.cpp"
#include "open303/src/rosic_Open303.cpp"
#include "open303/src/rosic_FunctionTemplates.cpp"
#include "open303/src/GlobalFunctions.cpp"
#include "open303/src/rosic_BlendOscillator.cpp"
#include "open303/src/rosic_BiquadFilter.cpp"
#include "open303/src/rosic_NumberManipulations.cpp"
#include "open303/src/rosic_OnePoleFilter.cpp"
#include "open303/src/rosic_MidiNoteEvent.cpp"
#include "open303/src/rosic_TeeBeeFilter.cpp"

#include "stmlib/stmlib.h"
#include "open303/src/rosic_Open303.h"
#include "open303/src/wavetable_gen/rosic_MipMappedWaveTable.h"

// static __attribute__((aligned(32))) uint8_t open303_mem[sizeof(rosic::Open303)];
static rosic::WaveTable square_wave;
static rosic::Open303 open303(&square_wave, &square_wave);

static float _pitch = -1;
static float _acc = 1.0f;
static float _cutoff = 0.25f;
static float _res = 0.33f;
static float _env = 0.25f;
static float _dec = 0.5f;
static float _note;
static uint8_t _waveform = 1;
static bool _gate;

void engine::setup()
{
    engine::addParam(V_OCT, &_pitch); // pitch is summed with CV and quantized
    engine::addParam("Acc", &_acc);
    engine::addParam("Cutoff", &_cutoff);
    engine::addParam("Reso", &_res);
    engine::addParam("EnvMod", &_env);
    engine::addParam("Dec", &_dec);

    // param[6].init("WAVEFORM", &_waveform, _waveform, 0, 1);
    // param[6].print_value = [&](char *val)
    // {
    //     sprintf(val, _waveform ? "SQR" : "SAW");
    // };

    // square_wave = (uint8_t *)malloc(sizeof(rosic::WaveTable));
    rosic::MipMappedWaveTable tmp;
    tmp.fillWithSquare303();
    tmp.generateMipMap(square_wave);
    // open303.oscillator.setWaveTables(_square, _square);

    open303.setSampleRate(SAMPLE_RATE, 1);
    open303.setWaveform(_waveform);
    open303.setTuning(open303.tuning);
    open303.setAmpSustain(0);
    open303.setAccentAttack(open303.accentAttack);
    open303.setPitchBend(0);
    open303.setSlideTime(open303.slideTime);
    open303.setVolume(-12);
    open303.filter.setMode(rosic::TeeBeeFilter::TB_303);
}

void engine::process()
{
    open303.setWaveform(_waveform);
    open303.setAccent(1.f + _acc * 99.f);
    open303.setCutoff(rosic::linToExp(_cutoff, 0.0, 1.0, 314.0, 2394.0));
    open303.setResonance(1.f + _res * 99.f);
    open303.setEnvMod(1.f + _env * 99.f);
    open303.setDecay(rosic::linToExp(_dec, 0.0, 1.0, 200.0, 2000.0));
    if (_acc > 0)
        open303.setAccentDecay(rosic::linToExp(_dec, 0.0, 1.0, 200.0, 2000.0));

    _note = (float)DEFAULT_NOTE + 24 + engine::cv() * 12;
    CONSTRAIN(_note, 0, 128);

    _gate |= engine::gate();

    if (engine::trig() > 0)
        open303.triggerNote(_note, _acc > 0);
    else if (!engine::gate())
    {
        open303.releaseNote(_note);
        _gate = false;
    }
    else
        open303.oscFreq = rosic::pitchToFreq(_note, open303.tuning);

    auto buffer = engine::outputBuffer<0>();
    for (int i = 0; i < FRAME_BUFFER_SIZE; i++)
        buffer[i] = open303.getSample();
}

void engine::screensaver()
{
    static uint32_t _r = 0;
    static const uint8_t _screenSaver[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, //>
        0x00, 0x80, 0x0f, 0xe0, 0x01, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x07, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x30, 0x00,
        0x00, 0x06, 0x00, 0x00, 0x60, 0x00, 0x00, 0x03, 0x00, 0x00, 0x80, 0x00,
        0x80, 0x01, 0x06, 0xc0, 0x00, 0x01, 0xc0, 0x00, 0x0f, 0xe0, 0x01, 0x03,
        0x60, 0x00, 0x0f, 0xe0, 0x01, 0x06, 0x30, 0x80, 0x1f, 0xf0, 0x03, 0x0c,
        0x10, 0x80, 0x1f, 0xf0, 0x03, 0x08, 0x18, 0x80, 0x1f, 0xf0, 0x03, 0x18,
        0x08, 0x80, 0x1f, 0xf0, 0x03, 0x10, 0x08, 0x80, 0x1f, 0xf0, 0x03, 0x30,
        0x04, 0x80, 0x1f, 0xf0, 0x03, 0x20, 0x04, 0x80, 0x1f, 0xf0, 0x03, 0x20,
        0x04, 0x80, 0x1f, 0xf0, 0x03, 0x60, 0x06, 0x00, 0x0f, 0xe0, 0x01, 0x40,
        0x02, 0x00, 0x0f, 0xe0, 0x01, 0x40, 0x02, 0x00, 0x06, 0xc0, 0x00, 0x40,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40,
        0xe2, 0x07, 0x00, 0x00, 0xe0, 0x47, 0xc2, 0x03, 0x00, 0x00, 0xc0, 0x43,
        0x82, 0x01, 0x00, 0x00, 0x80, 0x41, 0x82, 0x01, 0x00, 0x00, 0x80, 0x41,
        0x86, 0x01, 0x00, 0x00, 0xc0, 0x60, 0x04, 0x03, 0x00, 0x00, 0xc0, 0x60,
        0x04, 0x07, 0x00, 0x00, 0xc0, 0x20, 0x0c, 0x06, 0x00, 0x00, 0x60, 0x20,
        0x08, 0x0e, 0x00, 0x00, 0x70, 0x30, 0x08, 0x1c, 0x00, 0x00, 0x30, 0x10,
        0x18, 0x38, 0x00, 0x00, 0x1c, 0x18, 0x10, 0x70, 0x00, 0x00, 0x0e, 0x08,
        0x20, 0xe0, 0x00, 0x00, 0x0f, 0x0c, 0x60, 0xc0, 0x03, 0xc0, 0x03, 0x06,
        0xc0, 0x00, 0x0f, 0xf0, 0x00, 0x02, 0x80, 0x01, 0xfc, 0x3f, 0x00, 0x01,
        0x00, 0x03, 0xe0, 0x07, 0xc0, 0x00, 0x00, 0x06, 0x00, 0x00, 0x60, 0x00,
        0x00, 0x0c, 0x00, 0x00, 0x30, 0x00, 0x00, 0x30, 0x00, 0x00, 0x1c, 0x00,
        0x00, 0xe0, 0x00, 0x00, 0x07, 0x00, 0x00, 0x80, 0x0f, 0xf0, 0x01, 0x00,
        0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x01, 0x00, //>
        0x00, 0xe0, 0xff, 0xff, 0x07, 0x00, 0x00, 0xf0, 0x0f, 0xe0, 0x1f, 0x00,
        0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00,
        0x00, 0x0f, 0x00, 0x00, 0xf0, 0x00, 0x80, 0x07, 0x06, 0xc0, 0xe0, 0x01,
        0xc0, 0x03, 0x0f, 0xe0, 0x81, 0x03, 0xe0, 0x81, 0x1f, 0xf0, 0x83, 0x07,
        0xf0, 0x80, 0x1f, 0xf0, 0x03, 0x0f, 0x78, 0xc0, 0x3f, 0xf8, 0x07, 0x1e,
        0x38, 0xc0, 0x3f, 0xf8, 0x07, 0x1c, 0x3c, 0xc0, 0x3f, 0xf8, 0x07, 0x3c,
        0x1c, 0xc0, 0x3f, 0xf8, 0x07, 0x38, 0x1c, 0xc0, 0x3f, 0xf8, 0x07, 0x78,
        0x0e, 0xc0, 0x3f, 0xf8, 0x07, 0x70, 0x0e, 0xc0, 0x3f, 0xf8, 0x07, 0x70,
        0x0e, 0xc0, 0x1f, 0xf0, 0x07, 0xf0, 0x0f, 0x80, 0x1f, 0xf0, 0x03, 0xe0,
        0x07, 0x80, 0x0f, 0xe0, 0x03, 0xe0, 0x07, 0x00, 0x0f, 0xe0, 0x01, 0xe0,
        0x07, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xe7, 0x07, 0x00, 0x00, 0xe0, 0xe7,
        0xf7, 0x07, 0x00, 0x00, 0xe0, 0xef, 0xe7, 0x07, 0x00, 0x00, 0xe0, 0xe7,
        0xc7, 0x03, 0x00, 0x00, 0xc0, 0xe3, 0xc7, 0x03, 0x00, 0x00, 0xc0, 0xe3,
        0xcf, 0x03, 0x00, 0x00, 0xe0, 0xf1, 0x8e, 0x07, 0x00, 0x00, 0xe0, 0xf1,
        0x8e, 0x0f, 0x00, 0x00, 0xe0, 0x71, 0x1e, 0x0f, 0x00, 0x00, 0xf0, 0x70,
        0x1c, 0x1f, 0x00, 0x00, 0xf8, 0x78, 0x1c, 0x3e, 0x00, 0x00, 0x7c, 0x38,
        0x3c, 0x7c, 0x00, 0x00, 0x3e, 0x3c, 0x38, 0xf8, 0x00, 0x00, 0x1f, 0x1c,
        0x70, 0xf0, 0x03, 0xc0, 0x1f, 0x1e, 0xf0, 0xe0, 0x0f, 0xf0, 0x0f, 0x0f,
        0xe0, 0xc1, 0xff, 0xff, 0x03, 0x07, 0xc0, 0x03, 0xff, 0xff, 0xc0, 0x03,
        0x80, 0x07, 0xfc, 0x3f, 0xe0, 0x01, 0x00, 0x0f, 0xe0, 0x07, 0xf0, 0x00,
        0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00,
        0x00, 0xf0, 0x0f, 0xf0, 0x1f, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x07, 0x00,
        0x00, 0x80, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00};

    gfx::clearRect(0, 0, 128, 64);

    for (int i = 23; i > 0; i--)
    {
        if ((_r & (1 << i)))
            gfx::drawCircle(64, 32, 26 + powf(i, 1.3f));
    }

    if (_gate)
    {
        _r |= 1;
        gfx::drawXbm(40, 8, 48, 48, &_screenSaver[sizeof(_screenSaver) / 2]);
    }
    else
        gfx::drawXbm(40, 8, 48, 48, &_screenSaver[0]);

    _r <<= 1;
}